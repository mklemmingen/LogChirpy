import tensorflow as tfclass MelSpecLayerSimple(tf.keras.layers.Layer):    def __init__(self, sample_rate, spec_shape, frame_step, frame_length, fmin, fmax, data_format, **kwargs):        super(MelSpecLayerSimple, self).__init__(**kwargs)        self.sample_rate = sample_rate        self.spec_shape = spec_shape        self.data_format = data_format        self.frame_step = frame_step        self.frame_length = frame_length        self.fmin=fmin        self.fmax=fmax        self.mel_filterbank = tf.signal.linear_to_mel_weight_matrix(                                num_mel_bins=self.spec_shape[0],                                num_spectrogram_bins=self.frame_length // 2 + 1,                                sample_rate=self.sample_rate,                                lower_edge_hertz=self.fmin,                                upper_edge_hertz=self.fmax,                                dtype=tf.float32)      def build(self, input_shape):                   self.mag_scale = self.add_weight(name='magnitude_scaling',                                          initializer=tf.keras.initializers.Constant(value=1.23),                                         trainable=True)                                                  super(MelSpecLayerSimple, self).build(input_shape)            def compute_output_shape(self, input_shape):        if self.data_format == 'channels_last':            return tf.TensorShape((None, self.spec_shape[0], self.spec_shape[1], 1))        else:            return tf.TensorShape((None, 1, self.spec_shape[0], self.spec_shape[1]))    def call(self, inputs, training=None):        # Normalize values between -1 and 1        inputs = tf.math.subtract(inputs, tf.math.reduce_min(inputs, axis=1, keepdims=True))        inputs = tf.math.divide(inputs, tf.math.reduce_max(inputs, axis=1, keepdims=True) + 0.000001)        inputs = tf.math.subtract(inputs, 0.5)        inputs = tf.math.multiply(inputs, 2.0)                # Perform STFT            spec = tf.signal.stft(inputs,                              self.frame_length,                              self.frame_step,                              fft_length=self.frame_length,                              window_fn=tf.signal.hann_window,                              pad_end=False,                              name='stft')            # Cast from complex to float        spec = tf.dtypes.cast(spec, tf.float32)        # Apply mel scale                      spec = tf.tensordot(spec, self.mel_filterbank, 1)                # Convert to power spectrogram        spec = tf.math.pow(spec, 2.0)        # Convert magnitudes using nonlinearity        spec = tf.math.pow(spec, 1.0 / (1.0 + tf.math.exp(self.mag_scale)))        # Flip spec horizontally        spec = tf.reverse(spec, axis=[2])        # Swap axes to fit input shape        spec = tf.transpose(spec, [0, 2, 1])        # Add channel axis                if self.data_format == 'channels_last':            spec = tf.expand_dims(spec, -1)        else:            spec = tf.expand_dims(spec, 1)              return spec    def get_config(self):        config = {'data_format': self.data_format,                  'sample_rate': self.sample_rate,                  'spec_shape': self.spec_shape,                  'frame_step': self.frame_step,                  'fmin': self.fmin,                  'fmax': self.fmax,                  'frame_length': self.frame_length,                  'mel_filterbank': self.mel_filterbank.numpy().tolist()                  }        base_config = super(MelSpecLayerSimple, self).get_config()        return dict(list(base_config.items()) + list(config.items()))