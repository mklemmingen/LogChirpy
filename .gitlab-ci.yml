variables:
  GIT_DEPTH: 0  # ensures full clone including all history

stages:
  - deploy
  - typecheck

deploy-logchirpy:
  stage: deploy
  image: ruby:2.7
  script:
    - echo "Installing git-filter-repo..."
    - apt-get update && apt-get install -y python3 wget
    - wget https://raw.githubusercontent.com/newren/git-filter-repo/main/git-filter-repo -O /usr/local/bin/git-filter-repo
    - chmod +x /usr/local/bin/git-filter-repo

    - echo "Git setup..."
    - git config --global user.email "104225647+mklemmingen@users.noreply.github.com"
    - git config --global user.name "mklemmingen"
    - git checkout -B main

    - echo "Identifying large files in history..."
    - git rev-list --objects --all | git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' | awk '/^blob/ {if($3 > 100*1024*1024) print $4}' > large_files.txt
    - echo "Large files found:"
    - cat large_files.txt

    - echo "Removing all large files (>100MB) from history..."
    - |
      if [ -s large_files.txt ]; then
        while IFS= read -r file; do
          echo "Removing large file: $file"
          git-filter-repo --force --path "$file" --invert-paths
        done < large_files.txt
      else
        echo "No large files found"
      fi

    - echo "Removing specific problematic commit..."
    - >
      git-filter-repo --force --commit-callback '
        if commit.original_id == b"6dc08e153ae7aa2670a085104a1dbb95dd64254c":
            commit.skip()
      '

    - echo "Removing all .env files from history..."
    - >
      git-filter-repo --force
      --path-glob '**/.env'
      --invert-paths

    - echo "Rewriting all mklemmingen-related emails to GitHub address..."
    - >
      git-filter-repo --force --email-callback '
        if email in [b"martin.lauterbach@student.reutlingen-university.de", b"mklemmingen", b"mklemmingen@gmail.com", b"mklemmingen@users.noreply.github.com"]:
            return b"104225647+mklemmingen@users.noreply.github.com"
        return email
      '

    - echo "Blanking out commit messages containing 'Claude'..."
    - >
      git-filter-repo --force --message-callback '
        if b"Claude" in message:
            return b"Code update"
        return message
      '

    - echo "Final cleanup - removing any remaining files >100MB..."
    - git rev-list --objects --all | git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' | awk '/^blob/ {if($3 > 100*1024*1024) print $4}' > remaining_large_files.txt
    - |
      if [ -s remaining_large_files.txt ]; then
        echo "Removing remaining large files:"
        cat remaining_large_files.txt
        while IFS= read -r file; do
          git-filter-repo --force --path "$file" --invert-paths
        done < remaining_large_files.txt
      fi

    - echo "Pushing cleaned history to GitHub..."
    - git remote add origin https://x-access-token:${GITHUB_TOKEN}@github.com/mklemmingen/LogChirpy.git
    - git push --force origin main
    - echo "Successfully deployed cleaned GitHub history."
  only:
    - main
  environment: production

typescript-check:
  stage: typecheck
  image: node:18  # Use a Node.js image with npm
  before_script:
    # Clone the repository from GitHub to check the current state
    - git clone https://x-access-token:${GITHUB_TOKEN}@github.com/mklemmingen/LogChirpy.git ./project
    - cd ./project
  script:
    - echo "Installing dependencies..."
    - npm ci  # Use ci for faster, deterministic installs
    
    - echo "Running TypeScript type check..."
    - echo "========================================"
    - echo "TypeScript Errors and Warnings:"
    - echo "========================================"
    
    # Run tsc with specific flags to list all errors
    - npx tsc --noEmit --pretty --listFiles false || echo "TypeScript check completed with errors"
    
    - echo "========================================"
    - echo "TypeScript check finished"
  allow_failure: true  # Don't fail the pipeline if there are TS errors
  only:
    - main
  dependencies:
    - deploy-logchirpy  # Ensure this runs after deploy
  environment: production