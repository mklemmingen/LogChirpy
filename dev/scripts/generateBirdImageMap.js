#!/usr/bin/env node

/**
 * Generate Bird Image Map Script
 * 
 * Reads download_progress.json and generates a TypeScript file with
 * hardcoded require() statements for all bird images.
 * 
 * Features:
 * - Prefers .webp over .jpg for smaller bundle size
 * - Validates file existence before adding require() statements
 * - Generates clean TypeScript with consistent formatting
 * - Handles missing images gracefully
 */

const fs = require('fs');
const path = require('path');

// Configuration
const CONFIG = {
    downloadProgressPath: path.join(__dirname, '../image_getters/download_progress.json'),
    assetsDir: path.join(__dirname, '../../assets/images/birds'),
    outputPath: path.join(__dirname, '../../services/generated/BirdImageMap.ts'),
    relativePath: '../../assets/images/birds' // Relative path from generated file to assets
};

// Statistics tracking
const stats = {
    totalEntries: 0,
    foundWebp: 0,
    foundJpg: 0,
    notFound: 0,
    errors: 0
};

/**
 * Check if a file exists
 */
function fileExists(filePath) {
    try {
        return fs.existsSync(filePath);
    } catch (error) {
        console.warn(`Error checking file existence: ${filePath}`, error.message);
        return false;
    }
}

/**
 * Extract base filename from download progress entry
 */
function getBaseFilename(filename) {
    // Remove .webp or .jpg extension
    return filename.replace(/\.(webp|jpg)$/i, '');
}

/**
 * Find the best available image format for a bird
 */
function findBestImageFormat(latinName, downloadProgressFilename) {
    const baseFilename = getBaseFilename(downloadProgressFilename);
    
    // Check for .webp first (preferred)
    const webpPath = path.join(CONFIG.assetsDir, `${baseFilename}.webp`);
    const jpgPath = path.join(CONFIG.assetsDir, `${baseFilename}.jpg`);
    
    if (fileExists(webpPath)) {
        stats.foundWebp++;
        return `${baseFilename}.webp`;
    } else if (fileExists(jpgPath)) {
        stats.foundJpg++;
        return `${baseFilename}.jpg`;
    } else {
        stats.notFound++;
        console.warn(`No image found for ${latinName}: ${baseFilename}.webp or ${baseFilename}.jpg`);
        return null;
    }
}

/**
 * Generate TypeScript require statement
 */
function generateRequireStatement(filename) {
    return `require('${CONFIG.relativePath}/${filename}')`;
}

/**
 * Generate the complete TypeScript file content
 */
function generateTypeScriptContent(imageMap) {
    const entries = Object.entries(imageMap)
        .sort(([a], [b]) => a.localeCompare(b)) // Sort alphabetically
        .map(([filename, requireStatement]) => `  '${filename}': ${requireStatement}`)
        .join(',\n');

    return `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * 
 * This file is automatically generated by generateBirdImageMap.js
 * It contains hardcoded require() statements for all bird images
 * to ensure they are bundled by Metro bundler.
 * 
 * Generated: ${new Date().toISOString()}
 * Total images: ${Object.keys(imageMap).length}
 * WebP images: ${stats.foundWebp}
 * JPG images: ${stats.foundJpg}
 * Missing images: ${stats.notFound}
 */

export const birdImageMap: { [key: string]: any } = {
${entries}
};

export default birdImageMap;
`;
}

/**
 * Main function to generate the bird image map
 */
async function generateBirdImageMap() {
    console.log('üê¶ Generating Bird Image Map...');
    console.log(`üìÅ Reading from: ${CONFIG.downloadProgressPath}`);
    console.log(`üìÅ Assets directory: ${CONFIG.assetsDir}`);
    console.log(`üìÅ Output file: ${CONFIG.outputPath}`);
    
    try {
        // Read download progress
        if (!fileExists(CONFIG.downloadProgressPath)) {
            throw new Error(`Download progress file not found: ${CONFIG.downloadProgressPath}`);
        }
        
        const downloadProgressData = fs.readFileSync(CONFIG.downloadProgressPath, 'utf8');
        const downloadProgress = JSON.parse(downloadProgressData);
        
        stats.totalEntries = Object.keys(downloadProgress).length;
        console.log(`üìä Found ${stats.totalEntries} entries in download progress`);
        
        // Check assets directory
        if (!fileExists(CONFIG.assetsDir)) {
            throw new Error(`Assets directory not found: ${CONFIG.assetsDir}`);
        }
        
        // Generate image map
        const imageMap = {};
        
        for (const [latinName, filename] of Object.entries(downloadProgress)) {
            if (!filename) {
                stats.notFound++;
                continue; // Skip entries with empty filenames
            }
            
            try {
                const bestFormat = findBestImageFormat(latinName, filename);
                if (bestFormat) {
                    imageMap[bestFormat] = generateRequireStatement(bestFormat);
                }
            } catch (error) {
                stats.errors++;
                console.error(`Error processing ${latinName}:`, error.message);
            }
        }
        
        // Generate TypeScript content
        const typeScriptContent = generateTypeScriptContent(imageMap);
        
        // Ensure output directory exists
        const outputDir = path.dirname(CONFIG.outputPath);
        if (!fileExists(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }
        
        // Write the file
        fs.writeFileSync(CONFIG.outputPath, typeScriptContent, 'utf8');
        
        // Print statistics
        console.log('\\nüìä Generation Statistics:');
        console.log(`‚úÖ Total entries processed: ${stats.totalEntries}`);
        console.log(`üñºÔ∏è  WebP images found: ${stats.foundWebp}`);
        console.log(`üñºÔ∏è  JPG images found: ${stats.foundJpg}`);
        console.log(`‚ùå Images not found: ${stats.notFound}`);
        console.log(`‚ö†Ô∏è  Errors: ${stats.errors}`);
        console.log(`üìù Generated requires: ${Object.keys(imageMap).length}`);
        
        const coveragePercentage = Math.round((Object.keys(imageMap).length / stats.totalEntries) * 100);
        console.log(`üìà Coverage: ${coveragePercentage}%`);
        
        console.log(`\\n‚úÖ Successfully generated: ${CONFIG.outputPath}`);
        console.log(`üì¶ Ready for Metro bundler!`);
        
    } catch (error) {
        console.error('‚ùå Error generating bird image map:', error.message);
        process.exit(1);
    }
}

// Run the script if called directly
if (require.main === module) {
    generateBirdImageMap().catch(error => {
        console.error('‚ùå Unhandled error:', error);
        process.exit(1);
    });
}

module.exports = { generateBirdImageMap };